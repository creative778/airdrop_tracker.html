<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Multi-Chain Wallet Analyzer</title>
  <style>
    /* [Same CSS as before, but with additional styles for multi-chain support] */
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Multi-Chain Wallet Analyzer</h1>
      <div class="small muted">Supports all major EVM networks</div>
    </header>

    <div class="grid-2">
      <main>
        <div class="card">
          <label>Address or ENS</label>
          <input id="inputAddress" placeholder="0x... or alice.eth (optional)" />
          
          <div style="display:flex;gap:8px;margin-top:10px">
            <select id="selectNetwork">
              <!-- Add all major EVM networks -->
              <option value="ethereum">Ethereum</option>
              <option value="bsc">Binance Smart Chain</option>
              <option value="polygon">Polygon</option>
              <option value="optimism">Optimism</option>
              <option value="arbitrum">Arbitrum</option>
              <option value="sepolia">Sepolia (Testnet)</option>
            </select>
            <button id="btnAnalyze" class="btn">Analyze</button>
            <button id="btnClear" class="btn-ghost">Reset</button>
          </div>

          <div class="result" id="basicResult" style="margin-top:12px">
            <div><strong>Resolved Address:</strong> <span id="outAddress">—</span></div>
            <div><strong>ENS / Name:</strong> <span id="outENS">—</span></div>
            <div><strong>Network:</strong> <span id="outNetwork">—</span></div>
            <div><strong>Native Balance:</strong> <span id="outNative">—</span></div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <strong>Token Discovery</strong>
            <div class="small muted">Scan recent logs to find tokens</div>
          </div>

          <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
            <label class="small" style="width:140px">Scan depth (blocks)</label>
            <input id="scanDepth" type="number" value="5000" style="width:120px" />
            <div style="flex:1"></div>
            <div class="inline controls">
              <button id="btnDiscover" class="btn">Discover Tokens</button>
              <button id="btnRefreshBalances" class="btn-ghost">Refresh Balances</button>
            </div>
          </div>

          <div style="margin-top:10px">
            <div class="progress hidden" id="progressBar"><i></i></div>
            <div class="small muted" id="progressText">Waiting...</div>
          </div>

          <div class="tokens" id="tokensRoot"></div>
        </div>
      </main>

      <aside>
        <div class="card">
          <strong>Wallet Connect</strong>
          <div style="margin-top:8px">
            <button id="connectMetaMask" class="btn-ghost">Connect MetaMask</button>
            <button id="connectWalletConnect" class="btn-ghost">Connect WalletConnect</button>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <strong>Networks</strong>
          <div style="margin-top:8px">
            <select id="networkSelector">
              <!-- Same options as above -->
            </select>
          </div>
        </div>
      </aside>
    </div>

    <footer>Made by you — modify freely. Use responsibly. ©</footer>
  </div>

  <script>
    // Network configurations with default API keys
    const networks = {
      ethereum: { 
        name: 'Ethereum', 
        chainId: 1, 
        rpc: 'https://mainnet.infura.io/v3/51b4cd51199e4263b0435a4a97ca8971', 
        symbol: 'ETH',
        explorer: 'https://etherscan.io/address/'
      },
      bsc: { 
        name: 'Binance Smart Chain', 
        chainId: 56, 
        rpc: 'https://bsc-dataseed.bscscan.com', 
        symbol: 'BNB',
        explorer: 'https://bscscan.com/address/'
      },
      polygon: { 
        name: 'Polygon', 
        chainId: 137, 
        rpc: 'https://polygon-rpc.com', 
        symbol: 'MATIC',
        explorer: 'https://polygonscan.com/address/'
      },
      optimism: { 
        name: 'Optimism', 
        chainId: 10, 
        rpc: 'https://mainnet.optimism.io', 
        symbol: 'ETH',
        explorer: 'https://optimistic.etherscan.io/address/'
      },
      arbitrum: { 
        name: 'Arbitrum', 
        chainId: 42161, 
        rpc: 'https://arb1.arbitrum.io/rpc', 
        symbol: 'ETH',
        explorer: 'https://arbiscan.com/address/'
      },
      sepolia: { 
        name: 'Sepolia', 
        chainId: 11155111, 
        rpc: 'https://rpc.sepolia.org', 
        symbol: 'ETH',
        explorer: 'https://sepolia.etherscan.io/address/'
      }
    };

    // WalletConnect initialization
    let walletConnectProvider = null;
    const projectId = '20636708cdffc0d93dcbae15843dc4d6'; // Replace with your WalletConnect project ID

    // Initialize WalletConnect
    const wcOptions = {
      projectId,
      chains: [1, 56, 137, 10, 42161, 11155111],
      optionalChains: [1, 56, 137, 10, 42161, 11155111],
      showQrModal: true
    };

    const walletConnect = new WalletConnectProvider(wcOptions);

    // Connect MetaMask
    document.getElementById('connectMetaMask').addEventListener('click', async () => {
      if (!window.ethereum) {
        alert('MetaMask not found. Please install MetaMask.');
        return;
      }
      try {
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        document.getElementById('inputAddress').value = accounts[0];
      } catch (e) {
        console.error('MetaMask connection failed:', e);
      }
    });

    // Connect WalletConnect
    document.getElementById('connectWalletConnect').addEventListener('click', async () => {
      try {
        await walletConnect.enable();
        const accounts = await walletConnect.request({ method: 'eth_accounts' });
        document.getElementById('inputAddress').value = accounts[0];
      } catch (e) {
        console.error('WalletConnect failed:', e);
      }
    });

    // Main analysis logic
    let currentNetworkKey = 'ethereum';
    let currentAddress = null;
    let discoveredTokens = {};

    // Network selector
    document.getElementById('selectNetwork').addEventListener('change', (e) => {
      currentNetworkKey = e.target.value;
    });

    // Analyze button
    document.getElementById('btnAnalyze').addEventListener('click', async () => {
      const raw = document.getElementById('inputAddress').value.trim();
      currentNetworkKey = document.getElementById('selectNetwork').value;
      const addr = await resolveAddress(raw, currentNetworkKey);
      
      if (!addr) {
        alert('Invalid address/ENS or connection denied');
        return;
      }
      
      currentAddress = addr;
      const ensName = await lookupENS(addr, currentNetworkKey);
      const nativeBalance = await fetchNativeBalance(addr, currentNetworkKey);
      
      updateStatus(addr, ensName, currentNetworkKey, nativeBalance);
      discoveredTokens = {};
      renderTokensUI();
    });

    // Token discovery
    document.getElementById('btnDiscover').addEventListener('click', async () => {
      if (!currentAddress) {
        alert('Analyze an address first');
        return;
      }
      
      const depth = parseInt(document.getElementById('scanDepth').value) || 5000;
      document.getElementById('progressText').innerText = `Scanning last ${depth} blocks...`;
      document.getElementById('progressBar').classList.remove('hidden');
      
      try {
        const tokens = await discoverTokensByLogs(currentAddress, currentNetworkKey, depth);
        const tokenMetadata = await Promise.all(tokens.map(token => 
          fetchTokenMetadata(token, currentAddress, currentNetworkKey)
        ));
        
        discoveredTokens = {};
        tokenMetadata.forEach(token => {
          if (token.balance > 0) {
            discoveredTokens[token.address] = token;
          }
        });
        
        document.getElementById('progressText').innerText = `Found ${Object.keys(discoveredTokens).length} tokens`;
        renderTokensUI();
      } catch (e) {
        console.error('Discovery failed:', e);
        alert('Token discovery failed. Try reducing scan depth.');
      } finally {
        document.getElementById('progressBar').classList.add('hidden');
      }
    });

    // Helper functions
    async function resolveAddress(input, netKey) {
      const provider = new ethers.JsonRpcProvider(networks[netKey].rpc, networks[netKey].chainId);
      
      if (!input) {
        if (window.ethereum) {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          return ethers.getAddress(accounts[0]);
        }
        return null;
      }
      
      if (input.endsWith('.eth')) {
        try {
          return await provider.resolveName(input);
        } catch (e) {
          return null;
        }
      }
      
      try {
        return ethers.getAddress(input);
      } catch (e) {
        return null;
      }
    }

    async function lookupENS(address, netKey) {
      const provider = new ethers.JsonRpcProvider(networks[netKey].rpc, networks[netKey].chainId);
      try {
        return await provider.lookupAddress(address);
      } catch (e) {
        return null;
      }
    }

    async function fetchNativeBalance(address, netKey) {
      const provider = new ethers.JsonRpcProvider(networks[netKey].rpc, networks[netKey].chainId);
      try {
        const balance = await provider.getBalance(address);
        return ethers.formatEther(balance);
      } catch (e) {
        console.error('Balance fetch failed:', e);
        return null;
      }
    }

    async function discoverTokensByLogs(address, netKey, depth) {
      const provider = new ethers.JsonRpcProvider(networks[netKey].rpc, networks[netKey].chainId);
      const latest = await provider.getBlockNumber();
      const fromBlock = Math.max(0, latest - depth);
      
      const transferTopic = ethers.id("Transfer(address,address,uint256)");
      const tokens = new Set();
      
      for (let start = fromBlock; start <= latest; start += 1500) {
        const end = Math.min(latest, start + 1500);
        
        try {
          // Scan for tokens received by the address
          const filterTo = {
            fromBlock: start,
            toBlock: end,
            topics: [transferTopic, null, ethers.hexZeroPad(address.toLowerCase(), 32)]
          };
          
          const logsTo = await provider.getLogs(filterTo);
          logsTo.forEach(log => tokens.add(log.address));
          
          // Scan for tokens sent from the address
          const filterFrom = {
            fromBlock: start,
            toBlock: end,
            topics: [transferTopic, ethers.hexZeroPad(address.toLowerCase(), 32), null]
          };
          
          const logsFrom = await provider.getLogs(filterFrom);
          logsFrom.forEach(log => tokens.add(log.address));
        } catch (e) {
          console.warn('Chunk failed:', e);
        }
      }
      
      return Array.from(tokens);
    }

    async function fetchTokenMetadata(tokenAddress, userAddress, netKey) {
      const provider = new ethers.JsonRpcProvider(networks[netKey].rpc, networks[netKey].chainId);
      const contract = new ethers.Contract(tokenAddress, [
        "function name() view returns (string)",
        "function symbol() view returns (string)",
        "function decimals() view returns (uint8)",
        "function balanceOf(address) view returns (uint256)"
      ], provider);
      
      let name = '?', symbol = '?', decimals = 18, balance = '0';
      
      try { name = await contract.name(); } catch (e) {}
      try { symbol = await contract.symbol(); } catch (e) {}
      try { decimals = await contract.decimals(); } catch (e) {}
      try {
        const b = await contract.balanceOf(userAddress);
        balance = ethers.formatUnits(b, decimals);
      } catch (e) { console.warn('balanceOf failed', e); }
      
      return {
        address: tokenAddress,
        name,
        symbol,
        decimals,
        balance
      };
    }

    function updateStatus(addr, ens, netKey, native) {
      document.getElementById('outAddress').innerText = addr || '—';
      document.getElementById('outENS').innerText = ens || '—';
      document.getElementById('outNetwork').innerText = networks[netKey].name;
      document.getElementById('outNative').innerText = native ? `${native} ${networks[netKey].symbol}` : '—';
    }

    function renderTokensUI() {
      const root = document.getElementById('tokensRoot');
      root.innerHTML = '';
      
      if (Object.keys(discoveredTokens).length === 0) {
        root.innerHTML = '<div class="small muted">No tokens found. Try increasing scan depth.</div>';
        return;
      }
      
      const tokens = Object.values(discoveredTokens).sort((a, b) => 
        parseFloat(b.balance) - parseFloat(a.balance)
      );
      
      tokens.forEach(token => {
        const div = document.createElement('div');
        div.className = 'token-row';
        div.innerHTML = `
          <div>
            <div style="font-weight:600">${token.name} (${token.symbol})</div>
            <div class="small muted">${token.address}</div>
          </div>
          <div style="text-align:right">
            <div class="tag">${token.balance}</div>
            <div style="margin-top:6px">
              <a href="${networks[currentNetworkKey].explorer}${token.address}" target="_blank" class="btn-ghost">View</a>
            </div>
          </div>
        `;
        root.appendChild(div);
      });
    }
  </script>
</body>
</html>
