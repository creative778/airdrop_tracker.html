<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Multi-Chain Wallet Analyzer</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f9f9f9; }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 20px; }
    .card { background: #fff; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .btn { background: #4CAF50; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; }
    .btn-ghost { background: none; color: #4CAF50; border: 1px solid #4CAF50; padding: 8px 16px; border-radius: 4px; cursor: pointer; }
    .token-row { display: flex; justify-content: space-between; margin-bottom: 10px; }
    .progress { height: 4px; background: #4CAF50; width: 0%; transition: width 0.3s; }
    .hidden { display: none; }
    .muted { color: #666; }
    .tag { background: #e0e0e0; padding: 4px 8px; border-radius: 4px; }
    .error { color: red; font-weight: bold; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Multi-Chain Wallet Analyzer</h1>
      <div class="muted">Supports Ethereum, BSC, Polygon, Optimism, Arbitrum, and Sepolia</div>
    </header>

    <div class="grid-2">
      <main>
        <div class="card">
          <label>Address or ENS</label>
          <input id="inputAddress" placeholder="0x... or alice.eth" value="0x7a250d5630b4cf539739df2c5dacb4c659f2488d" />
          
          <div style="display:flex;gap:8px;margin-top:10px">
            <select id="selectNetwork">
              <option value="ethereum">Ethereum</option>
              <option value="bsc">Binance Smart Chain</option>
              <option value="polygon">Polygon</option>
              <option value="optimism">Optimism</option>
              <option value="arbitrum">Arbitrum</option>
              <option value="sepolia">Sepolia (Testnet)</option>
            </select>
            <button id="btnAnalyze" class="btn">Analyze</button>
            <button id="btnClear" class="btn-ghost">Reset</button>
          </div>

          <div class="result" id="basicResult" style="margin-top:12px">
            <div><strong>Resolved Address:</strong> <span id="outAddress">—</span></div>
            <div><strong>ENS / Name:</strong> <span id="outENS">—</span></div>
            <div><strong>Network:</strong> <span id="outNetwork">—</span></div>
            <div><strong>Native Balance:</strong> <span id="outNative">—</span></div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <strong>Token Discovery</strong>
            <div class="muted">Scan recent logs to find tokens</div>
          </div>

          <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
            <label class="muted" style="width:140px">Scan depth (blocks)</label>
            <input id="scanDepth" type="number" value="500" style="width:120px" />
            <div style="flex:1"></div>
            <div class="inline controls">
              <button id="btnDiscover" class="btn">Discover Tokens</button>
              <button id="btnRefreshBalances" class="btn-ghost">Refresh Balances</button>
            </div>
          </div>

          <div style="margin-top:10px">
            <div class="progress hidden" id="progressBar"><i></i></div>
            <div class="muted" id="progressText">Waiting...</div>
            <div class="error" id="errorMsg"></div>
          </div>

          <div class="tokens" id="tokensRoot"></div>
        </div>
      </main>

      <aside>
        <div class="card">
          <strong>Wallet Connect</strong>
          <div style="margin-top:8px">
            <button id="connectMetaMask" class="btn-ghost">Connect MetaMask</button>
            <button id="connectWalletConnect" class="btn-ghost">Connect WalletConnect</button>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <strong>Networks</strong>
          <div style="margin-top:8px">
            <select id="networkSelector">
              <option value="ethereum">Ethereum</option>
              <option value="bsc">Binance Smart Chain</option>
              <option value="polygon">Polygon</option>
              <option value="optimism">Optimism</option>
              <option value="arbitrum">Arbitrum</option>
              <option value="sepolia">Sepolia (Testnet)</option>
            </select>
          </div>
        </div>
      </aside>
    </div>

    <footer>Made by June AI - Use responsibly. © 2025</footer>
  </div>

  <!-- Dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.12.1/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.7.6/dist/web3-provider.min.js"></script>

  <script>
    // Network configurations with public RPCs (replace with your own API keys for better performance)
    const networks = {
      ethereum: { 
        name: 'Ethereum', 
        chainId: 1, 
        rpc: 'https://eth-mainnet.g.alchemy.com/v2/51b4cd51199e4263b0435a4a97ca8971', 
        symbol: 'ETH',
        explorer: 'https://etherscan.io/address/'
      },
      bsc: { 
        name: 'Binance Smart Chain', 
        chainId: 56, 
        rpc: 'https://bsc-mainnet.g.alchemy.com/v2/51b4cd51199e4263b0435a4a97ca8971', 
        symbol: 'BNB',
        explorer: 'https://bscscan.com/address/'
      },
      polygon: { 
        name: 'Polygon', 
        chainId: 137, 
        rpc: 'https://polygon-mainnet.g.alchemy.com/v2/51b4cd51199e4263b0435a4a97ca8971', 
        symbol: 'MATIC',
        explorer: 'https://polygonscan.com/address/'
      },
      optimism: { 
        name: 'Optimism', 
        chainId: 10, 
        rpc: 'https://opt-mainnet.g.alchemy.com/v2/51b4cd51199e4263b0435a4a97ca8971', 
        symbol: 'ETH',
        explorer: 'https://optimistic.etherscan.io/address/'
      },
      arbitrum: { 
        name: 'Arbitrum', 
        chainId: 42161, 
        rpc: 'https://arb-mainnet.g.alchemy.com/v2/51b4cd51199e4263b0435a4a97ca8971', 
        symbol: 'ETH',
        explorer: 'https://arbiscan.io/address/'
      },
      sepolia: { 
        name: 'Sepolia', 
        chainId: 11155111, 
        rpc: 'https://eth-sepolia.g.alchemy.com/v2/51b4cd51199e4263b0435a4a97ca8971', 
        symbol: 'ETH',
        explorer: 'https://sepolia.etherscan.io/address/'
      }
    };

    // WalletConnect initialization
    const walletConnect = new Web3Provider({
      projectId: '20636708cdffc0d93dcbae15843dc4d6', // Replace with your WalletConnect project ID
      chains: [1, 56, 137, 10, 42161, 11155111],
      showQrModal: true
    });

    let currentNetworkKey = 'ethereum';
    let currentAddress = null;
    let discoveredTokens = {};

    // Network selector
    document.getElementById('selectNetwork').addEventListener('change', (e) => {
      currentNetworkKey = e.target.value;
    });

    // Analyze button
    document.getElementById('btnAnalyze').addEventListener('click', async () => {
      const raw = document.getElementById('inputAddress').value.trim();
      currentNetworkKey = document.getElementById('selectNetwork').value;
      
      try {
        const addr = await resolveAddress(raw, currentNetworkKey);
        if (!addr) {
          alert('Invalid address/ENS or connection denied');
          return;
        }
        
        currentAddress = addr;
        const ensName = await lookupENS(addr, currentNetworkKey);
        const nativeBalance = await fetchNativeBalance(addr, currentNetworkKey);
        
        updateStatus(addr, ensName, currentNetworkKey, nativeBalance);
        discoveredTokens = {};
        renderTokensUI();
      } catch (error) {
        console.error('Analysis failed:', error);
        document.getElementById('errorMsg').innerText = 'Error: ' + error.message;
      }
    });

    // Token discovery
    document.getElementById('btnDiscover').addEventListener('click', async () => {
      if (!currentAddress) {
        alert('Analyze an address first');
        return;
      }
      
      const depth = parseInt(document.getElementById('scanDepth').value) || 500;
      document.getElementById('progressText').innerText = `Scanning last ${depth} blocks...`;
      document.getElementById('progressBar').classList.remove('hidden');
      document.getElementById('errorMsg').innerText = '';
      
      try {
        const tokens = await discoverTokensByLogs(currentAddress, currentNetworkKey, depth);
        const tokenMetadata = await Promise.all(tokens.map(token => 
          fetchTokenMetadata(token, currentAddress, currentNetworkKey)
        ));
        
        discoveredTokens = {};
        tokenMetadata.forEach(token => {
          if (token.balance > 0) {
            discoveredTokens[token.address] = token;
          }
        });
        
        document.getElementById('progressText').innerText = `Found ${Object.keys(discoveredTokens).length} tokens`;
        renderTokensUI();
      } catch (e) {
        console.error('Discovery failed:', e);
        document.getElementById('errorMsg').innerText = 'Error: ' + e.message;
      } finally {
        document.getElementById('progressBar').classList.add('hidden');
      }
    });

    // Connect MetaMask
    document.getElementById('connectMetaMask').addEventListener('click', async () => {
      if (!window.ethereum) {
        alert('MetaMask not found. Please install MetaMask.');
        return;
      }
      try {
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        document.getElementById('inputAddress').value = accounts[0];
      } catch (e) {
        console.error('MetaMask connection failed:', e);
      }
    });

    // Connect WalletConnect
    document.getElementById('connectWalletConnect').addEventListener('click', async () => {
      try {
        await walletConnect.enable();
        const accounts = await walletConnect.request({ method: 'eth_accounts' });
        document.getElementById('inputAddress').value = accounts[0];
      } catch (e) {
        console.error('WalletConnect failed:', e);
      }
    });

    // Helper functions
    async function resolveAddress(input, netKey) {
      const provider = new ethers.BrowserProvider(window.ethereum || networks[netKey].rpc);
      
      if (!input) {
        if (window.ethereum) {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          return ethers.getAddress(accounts[0]);
        }
        return null;
      }
      
      if (input.endsWith('.eth')) {
        try {
          return await provider.resolveName(input);
        } catch (e) {
          return null;
        }
      }
      
      try {
        return ethers.getAddress(input);
      } catch (e) {
        return null;
      }
    }

    async function lookupENS(address, netKey) {
      const provider = new ethers.BrowserProvider(window.ethereum || networks[netKey].rpc);
      try {
        return await provider.lookupAddress(address);
      } catch (e) {
        return null;
      }
    }

    async function fetchNativeBalance(address, netKey) {
      const provider = new ethers.BrowserProvider(window.ethereum || networks[netKey].rpc);
      try {
        const balance = await provider.getBalance(address);
        return ethers.formatEther(balance);
      } catch (e) {
        console.error('Balance fetch failed:', e);
        return 'Error: ' + e.message;
      }
    }

    async function discoverTokensByLogs(address, netKey, depth) {
      const provider = new ethers.BrowserProvider(window.ethereum || networks[netKey].rpc);
      const latest = await provider.getBlockNumber();
      const fromBlock = Math.max(0, latest - depth);
      
      const transferTopic = ethers.id("Transfer(address,address,uint256)");
      const tokens = new Set();
      
      for (let start = fromBlock; start <= latest; start += 1500) {
        const end = Math.min(latest, start + 1500);
        
        try {
          // Scan for tokens received by the address
          const filterTo = {
            fromBlock: start,
            toBlock: end,
            topics: [transferTopic, null, ethers.hexZeroPad(address.toLowerCase(), 32)]
          };
          
          const logsTo = await provider.getLogs(filterTo);
          logsTo.forEach(log => tokens.add(log.address));
          
          // Scan for tokens sent from the address
          const filterFrom = {
            fromBlock: start,
            toBlock: end,
            topics: [transferTopic, ethers.hexZeroPad(address.toLowerCase(), 32), null]
          };
          
          const logsFrom = await provider.getLogs(filterFrom);
          logsFrom.forEach(log => tokens.add(log.address));
        } catch (e) {
          console.warn('Chunk failed:', e);
        }
      }
      
      return Array.from(tokens);
    }

    async function fetchTokenMetadata(tokenAddress, userAddress, netKey) {
      const provider = new ethers.BrowserProvider(window.ethereum || networks[netKey].rpc);
      const contract = new ethers.Contract(tokenAddress, [
        "function name() view returns (string)",
        "function symbol() view returns (string)",
        "function decimals() view returns (uint8)",
        "function balanceOf(address) view returns (uint256)"
      ], provider);
      
      let name = '?', symbol = '?', decimals = 18, balance = '0';
      
      try { name = await contract.name(); } catch (e) {}
      try { symbol = await contract.symbol(); } catch (e) {}
      try { decimals = await contract.decimals(); } catch (e) {}
      try {
        const b = await contract.balanceOf(userAddress);
        balance = ethers.formatUnits(b, decimals);
      } catch (e) { console.warn('balanceOf failed', e); }
      
      return {
        address: tokenAddress,
        name,
        symbol,
        decimals,
        balance
      };
    }

    function updateStatus(addr, ens, netKey, native) {
      document.getElementById('outAddress').innerText = addr || '—';
      document.getElementById('outENS').innerText = ens || '—';
      document.getElementById('outNetwork').innerText = networks[netKey].name;
      document.getElementById('outNative').innerText = native ? `${native} ${networks[netKey].symbol}` : '—';
    }

    function renderTokensUI() {
      const root = document.getElementById('tokensRoot');
      root.innerHTML = '';
      
      if (Object.keys(discoveredTokens).length === 0) {
        root.innerHTML = '<div class="muted">No tokens found. Try increasing scan depth.</div>';
        return;
      }
      
      const tokens = Object.values(discoveredTokens).sort((a, b) => 
        parseFloat(b.balance) - parseFloat(a.balance)
      );
      
      tokens.forEach(token => {
        const div = document.createElement('div');
        div.className = 'token-row';
        div.innerHTML = `
          <div>
            <div style="font-weight:600">${token.name} (${token.symbol})</div>
            <div class="muted">${token.address}</div>
          </div>
          <div style="text-align:right">
            <div class="tag">${token.balance}</div>
            <div style="margin-top:6px">
              <a href="${networks[currentNetworkKey].explorer}${token.address}" target="_blank" class="btn-ghost">View</a>
            </div>
          </div>
        `;
        root.appendChild(div);
      });
    }
  </script>
</body>
</html>
